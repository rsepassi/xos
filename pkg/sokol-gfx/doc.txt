sokol_gfx.h -- simple 3D API wrapper

Project URL: https://github.com/floooh/sokol

Example code: https://github.com/floooh/sokol-samples

Do this:
    #define SOKOL_IMPL or
    #define SOKOL_GFX_IMPL
before you include this file in *one* C or C++ file to create the
implementation.

In the same place define one of the following to select the rendering
backend:
    #define SOKOL_GLCORE
    #define SOKOL_GLES3
    #define SOKOL_D3D11
    #define SOKOL_METAL
    #define SOKOL_WGPU
    #define SOKOL_DUMMY_BACKEND

I.e. for the desktop GL it should look like this:

#include ...
#include ...
#define SOKOL_IMPL
#define SOKOL_GLCORE
#include "sokol_gfx.h"

The dummy backend replaces the platform-specific backend code with empty
stub functions. This is useful for writing tests that need to run on the
command line.

Optionally provide the following defines with your own implementations:

SOKOL_ASSERT(c)             - your own assert macro (default: assert(c))
SOKOL_UNREACHABLE()         - a guard macro for unreachable code (default: assert(false))
SOKOL_GFX_API_DECL          - public function declaration prefix (default: extern)
SOKOL_API_DECL              - same as SOKOL_GFX_API_DECL
SOKOL_API_IMPL              - public function implementation prefix (default: -)
SOKOL_TRACE_HOOKS           - enable trace hook callbacks (search below for TRACE HOOKS)
SOKOL_EXTERNAL_GL_LOADER    - indicates that you're using your own GL loader, in this case
                              sokol_gfx.h will not include any platform GL headers and disable
                              the integrated Win32 GL loader

If sokol_gfx.h is compiled as a DLL, define the following before
including the declaration or implementation:

SOKOL_DLL

On Windows, SOKOL_DLL will define SOKOL_GFX_API_DECL as __declspec(dllexport)
or __declspec(dllimport) as needed.

If you want to compile without deprecated structs and functions,
define:

SOKOL_NO_DEPRECATED

Optionally define the following to force debug checks and validations
even in release mode:

SOKOL_DEBUG         - by default this is defined if _DEBUG is defined

sokol_gfx DOES NOT:
===================
- create a window, swapchain or the 3D-API context/device, you must do this
  before sokol_gfx is initialized, and pass any required information
  (like 3D device pointers) to the sokol_gfx initialization call

- present the rendered frame, how this is done exactly usually depends
  on how the window and 3D-API context/device was created

- provide a unified shader language, instead 3D-API-specific shader
  source-code or shader-bytecode must be provided (for the "official"
  offline shader cross-compiler, see here:
  https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md)


STEP BY STEP
============
--- to initialize sokol_gfx, after creating a window and a 3D-API
    context/device, call:

        sg_setup(const sg_desc*)

    Depending on the selected 3D backend, sokol-gfx requires some
    information, like a device pointer, default swapchain pixel formats
    and so on. If you are using sokol_app.h for the window system
    glue, you can use a helper function provided in the sokol_glue.h
    header:

        #include "sokol_gfx.h"
        #include "sokol_app.h"
        #include "sokol_glue.h"
        //...
        sg_setup(&(sg_desc){
            .environment = sglue_environment(),
        });

    To get any logging output for errors and from the validation layer, you
    need to provide a logging callback. Easiest way is through sokol_log.h:

        #include "sokol_log.h"
        //...
        sg_setup(&(sg_desc){
            //...
            .logger.func = slog_func,
        });

--- create resource objects (at least buffers, shaders and pipelines,
    and optionally images, samplers and render-pass-attachments):

        sg_buffer sg_make_buffer(const sg_buffer_desc*)
        sg_image sg_make_image(const sg_image_desc*)
        sg_sampler sg_make_sampler(const sg_sampler_desc*)
        sg_shader sg_make_shader(const sg_shader_desc*)
        sg_pipeline sg_make_pipeline(const sg_pipeline_desc*)
        sg_attachments sg_make_attachments(const sg_attachments_desc*)

--- start a render pass:

        sg_begin_pass(const sg_pass* pass);

    Typically, passes render into an externally provided swapchain which
    presents the rendering result on the display. Such a 'swapchain pass'
    is started like this:

        sg_begin_pass(&(sg_pass){ .action = { ... }, .swapchain = sglue_swapchain() })

    ...where .action is an sg_pass_action struct containing actions to be performed
    at the start and end of a render pass (such as clearing the render surfaces to
    a specific color), and .swapchain is an sg_swapchain
    struct all the required information to render into the swapchain's surfaces.

    To start an 'offscreen pass' into sokol-gfx image objects, an sg_attachment
    object handle is required instead of an sg_swapchain struct. An offscreen
    pass is started like this (assuming attachments is an sg_attachments handle):

        sg_begin_pass(&(sg_pass){ .action = { ... }, .attachments = attachments });

--- set the render pipeline state for the next draw call with:

        sg_apply_pipeline(sg_pipeline pip)

--- fill an sg_bindings struct with the resource bindings for the next
    draw call (0..N vertex buffers, 0 or 1 index buffer, 0..N image-objects,
    samplers and storage-buffers), and call:

        sg_apply_bindings(const sg_bindings* bindings)

    to update the resource bindings

--- optionally update shader uniform data with:

        sg_apply_uniforms(sg_shader_stage stage, int ub_index, const sg_range* data)

    Read the section 'UNIFORM DATA LAYOUT' to learn about the expected memory layout
    of the uniform data passed into sg_apply_uniforms().

--- kick off a draw call with:

        sg_draw(int base_element, int num_elements, int num_instances)

    The sg_draw() function unifies all the different ways to render primitives
    in a single call (indexed vs non-indexed rendering, and instanced vs non-instanced
    rendering). In case of indexed rendering, base_element and num_element specify
    indices in the currently bound index buffer. In case of non-indexed rendering
    base_element and num_elements specify vertices in the currently bound
    vertex-buffer(s). To perform instanced rendering, the rendering pipeline
    must be setup for instancing (see sg_pipeline_desc below), a separate vertex buffer
    containing per-instance data must be bound, and the num_instances parameter
    must be > 1.

--- finish the current rendering pass with:

        sg_end_pass()

--- when done with the current frame, call

        sg_commit()

--- at the end of your program, shutdown sokol_gfx with:

        sg_shutdown()

--- if you need to destroy resources before sg_shutdown(), call:

        sg_destroy_buffer(sg_buffer buf)
        sg_destroy_image(sg_image img)
        sg_destroy_sampler(sg_sampler smp)
        sg_destroy_shader(sg_shader shd)
        sg_destroy_pipeline(sg_pipeline pip)
        sg_destroy_attachments(sg_attachments atts)

--- to set a new viewport rectangle, call

        sg_apply_viewport(int x, int y, int width, int height, bool origin_top_left)

    ...or if you want to specify the viewport rectangle with float values:

        sg_apply_viewportf(float x, float y, float width, float height, bool origin_top_left)

--- to set a new scissor rect, call:

        sg_apply_scissor_rect(int x, int y, int width, int height, bool origin_top_left)

    ...or with float values:

        sg_apply_scissor_rectf(float x, float y, float width, float height, bool origin_top_left)

    Both sg_apply_viewport() and sg_apply_scissor_rect() must be called
    inside a rendering pass

    Note that sg_begin_default_pass() and sg_begin_pass() will reset both the
    viewport and scissor rectangles to cover the entire framebuffer.

--- to update (overwrite) the content of buffer and image resources, call:

        sg_update_buffer(sg_buffer buf, const sg_range* data)
        sg_update_image(sg_image img, const sg_image_data* data)

    Buffers and images to be updated must have been created with
    SG_USAGE_DYNAMIC or SG_USAGE_STREAM

    Only one update per frame is allowed for buffer and image resources when
    using the sg_update_*() functions. The rationale is to have a simple
    countermeasure to avoid the CPU scribbling over data the GPU is currently
    using, or the CPU having to wait for the GPU

    Buffer and image updates can be partial, as long as a rendering
    operation only references the valid (updated) data in the
    buffer or image.

--- to append a chunk of data to a buffer resource, call:

        int sg_append_buffer(sg_buffer buf, const sg_range* data)

    The difference to sg_update_buffer() is that sg_append_buffer()
    can be called multiple times per frame to append new data to the
    buffer piece by piece, optionally interleaved with draw calls referencing
    the previously written data.

    sg_append_buffer() returns a byte offset to the start of the
    written data, this offset can be assigned to
    sg_bindings.vertex_buffer_offsets[n] or
    sg_bindings.index_buffer_offset

    Code example:

    for (...) {
        const void* data = ...;
        const int num_bytes = ...;
        int offset = sg_append_buffer(buf, &(sg_range) { .ptr=data, .size=num_bytes });
        bindings.vertex_buffer_offsets[0] = offset;
        sg_apply_pipeline(pip);
        sg_apply_bindings(&bindings);
        sg_apply_uniforms(...);
        sg_draw(...);
    }

    A buffer to be used with sg_append_buffer() must have been created
    with SG_USAGE_DYNAMIC or SG_USAGE_STREAM.

    If the application appends more data to the buffer then fits into
    the buffer, the buffer will go into the "overflow" state for the
    rest of the frame.

    Any draw calls attempting to render an overflown buffer will be
    silently dropped (in debug mode this will also result in a
    validation error).

    You can also check manually if a buffer is in overflow-state by calling

        bool sg_query_buffer_overflow(sg_buffer buf)

    You can manually check to see if an overflow would occur before adding
    any data to a buffer by calling

        bool sg_query_buffer_will_overflow(sg_buffer buf, size_t size)

    NOTE: Due to restrictions in underlying 3D-APIs, appended chunks of
    data will be 4-byte aligned in the destination buffer. This means
    that there will be gaps in index buffers containing 16-bit indices
    when the number of indices in a call to sg_append_buffer() is
    odd. This isn't a problem when each call to sg_append_buffer()
    is associated with one draw call, but will be problematic when
    a single indexed draw call spans several appended chunks of indices.

--- to check at runtime for optional features, limits and pixelformat support,
    call:

        sg_features sg_query_features()
        sg_limits sg_query_limits()
        sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt)

--- if you need to call into the underlying 3D-API directly, you must call:

        sg_reset_state_cache()

    ...before calling sokol_gfx functions again

--- you can inspect the original sg_desc structure handed to sg_setup()
    by calling sg_query_desc(). This will return an sg_desc struct with
    the default values patched in instead of any zero-initialized values

--- you can get a desc struct matching the creation attributes of a
    specific resource object via:

        sg_buffer_desc sg_query_buffer_desc(sg_buffer buf)
        sg_image_desc sg_query_image_desc(sg_image img)
        sg_sampler_desc sg_query_sampler_desc(sg_sampler smp)
        sg_shader_desc sq_query_shader_desc(sg_shader shd)
        sg_pipeline_desc sg_query_pipeline_desc(sg_pipeline pip)
        sg_attachments_desc sg_query_attachments_desc(sg_attachments atts)

    ...but NOTE that the returned desc structs may be incomplete, only
    creation attributes that are kept around internally after resource
    creation will be filled in, and in some cases (like shaders) that's
    very little. Any missing attributes will be set to zero. The returned
    desc structs might still be useful as partial blueprint for creating
    similar resources if filled up with the missing attributes.

    Calling the query-desc functions on an invalid resource will return
    completely zeroed structs (it makes sense to check  the resource state
    with sg_query_*_state() first)

--- you can query the default resource creation parameters through the functions

        sg_buffer_desc sg_query_buffer_defaults(const sg_buffer_desc* desc)
        sg_image_desc sg_query_image_defaults(const sg_image_desc* desc)
        sg_sampler_desc sg_query_sampler_defaults(const sg_sampler_desc* desc)
        sg_shader_desc sg_query_shader_defaults(const sg_shader_desc* desc)
        sg_pipeline_desc sg_query_pipeline_defaults(const sg_pipeline_desc* desc)
        sg_attachments_desc sg_query_attachments_defaults(const sg_attachments_desc* desc)

    These functions take a pointer to a desc structure which may contain
    zero-initialized items for default values. These zero-init values
    will be replaced with their concrete values in the returned desc
    struct.

--- you can inspect various internal resource runtime values via:

        sg_buffer_info sg_query_buffer_info(sg_buffer buf)
        sg_image_info sg_query_image_info(sg_image img)
        sg_sampler_info sg_query_sampler_info(sg_sampler smp)
        sg_shader_info sg_query_shader_info(sg_shader shd)
        sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip)
        sg_attachments_info sg_query_attachments_info(sg_attachments atts)

    ...please note that the returned info-structs are tied quite closely
    to sokol_gfx.h internals, and may change more often than other
    public API functions and structs.

--- you can query frame stats and control stats collection via:

        sg_query_frame_stats()
        sg_enable_frame_stats()
        sg_disable_frame_stats()
        sg_frame_stats_enabled()

--- you can ask at runtime what backend sokol_gfx.h has been compiled for:

        sg_backend sg_query_backend(void)

--- call the following helper functions to compute the number of
    bytes in a texture row or surface for a specific pixel format.
    These functions might be helpful when preparing image data for consumption
    by sg_make_image() or sg_update_image():

        int sg_query_row_pitch(sg_pixel_format fmt, int width, int int row_align_bytes);
        int sg_query_surface_pitch(sg_pixel_format fmt, int width, int height, int row_align_bytes);

    Width and height are generally in number pixels, but note that 'row' has different meaning
    for uncompressed vs compressed pixel formats: for uncompressed formats, a row is identical
    with a single line if pixels, while in compressed formats, one row is a line of *compression blocks*.

    This is why calling sg_query_surface_pitch() for a compressed pixel format and height
    N, N+1, N+2, ... may return the same result.

    The row_align_bytes parammeter is for added flexibility. For image data that goes into
    the sg_make_image() or sg_update_image() this should generally be 1, because these
    functions take tightly packed image data as input no matter what alignment restrictions
    exist in the backend 3D APIs.

ON INITIALIZATION:
==================
When calling sg_setup(), a pointer to an sg_desc struct must be provided
which contains initialization options. These options provide two types
of information to sokol-gfx:

    (1) upper bounds and limits needed to allocate various internal
        data structures:
            - the max number of resources of each type that can
              be alive at the same time, this is used for allocating
              internal pools
            - the max overall size of uniform data that can be
              updated per frame, including a worst-case alignment
              per uniform update (this worst-case alignment is 256 bytes)
            - the max size of all dynamic resource updates (sg_update_buffer,
              sg_append_buffer and sg_update_image) per frame
        Not all of those limit values are used by all backends, but it is
        good practice to provide them none-the-less.

    (2) 3D backend "environment information" in a nested sg_environment struct:
        - pointers to backend-specific context- or device-objects (for instance
          the D3D11, WebGPU or Metal device objects)
        - defaults for external swapchain pixel formats and sample counts,
          these will be used as default values in image and pipeline objects,
          and the sg_swapchain struct passed into sg_begin_pass()
        Usually you provide a complete sg_environment struct through
        a helper function, as an example look at the sglue_environment()
        function in the sokol_glue.h header.

See the documentation block of the sg_desc struct below for more information.


ON RENDER PASSES
================
Relevant samples:
    - https://floooh.github.io/sokol-html5/offscreen-sapp.html
    - https://floooh.github.io/sokol-html5/offscreen-msaa-sapp.html
    - https://floooh.github.io/sokol-html5/mrt-sapp.html
    - https://floooh.github.io/sokol-html5/mrt-pixelformats-sapp.html

A render pass groups rendering commands into a set of render target images
(called 'pass attachments'). Render target images can be used in subsequent
passes as textures (it is invalid to use the same image both as render target
and as texture in the same pass).

The following sokol-gfx functions must only be called inside a render pass:

    sg_apply_viewport(f)
    sg_apply_scissor_rect(f)
    sg_apply_pipeline
    sg_apply_bindings
    sg_apply_uniforms
    sg_draw

A frame must have at least one 'swapchain render pass' which renders into an
externally provided swapchain provided as an sg_swapchain struct to the
sg_begin_pass() function. The sg_swapchain struct must contain the
following information:

    - the color pixel-format of the swapchain's render surface
    - an optional depth/stencil pixel format if the swapchain
      has a depth/stencil buffer
    - an optional sample-count for MSAA rendering
    - NOTE: the above three values can be zero-initialized, in that
      case the defaults from the sg_environment struct will be used that
      had been passed to the sg_setup() function.
    - a number of backend specific objects:
        - GL/GLES3: just a GL framebuffer handle
        - D3D11:
            - an ID3D11RenderTargetView for the rendering surface
            - if MSAA is used, an ID3D11RenderTargetView as
              MSAA resolve-target
            - an optional ID3D11DepthStencilView for the
              depth/stencil buffer
        - WebGPU
            - a WGPUTextureView object for the rendering surface
            - if MSAA is used, a WGPUTextureView object as MSAA resolve target
            - an optional WGPUTextureView for the
        - Metal (NOTE that the roles of provided surfaces is slightly
          different in Metal than in D3D11 or WebGPU, notably, the
          CAMetalDrawable is either rendered to directly, or serves
          as MSAA resolve target):
            - a CAMetalDrawable object which is either rendered
              into directly, or in case of MSAA rendering, serves
              as MSAA-resolve-target
            - if MSAA is used, an multisampled MTLTexture where
              rendering goes into
            - an optional MTLTexture for the depth/stencil buffer

It's recommended that you create a helper function which returns an
initialized sg_swapchain struct by value. This can then be directly plugged
into the sg_begin_pass function like this:

    sg_begin_pass(&(sg_pass){ .swapchain = sglue_swapchain() });

As an example for such a helper function check out the function sglue_swapchain()
in the sokol_glue.h header.

For offscreen render passes, the render target images used in a render pass
are baked into an immutable sg_attachments object.

For a simple offscreen scenario with one color-, one depth-stencil-render
target and without multisampling, creating an attachment object looks like this:

First create two render target images, one with a color pixel format,
and one with the depth- or depth-stencil pixel format. Both images
must have the same dimensions:

    const sg_image color_img = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = 256,
        .height = 256,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .sample_count = 1,
    });
    const sg_image depth_img = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = 256,
        .height = 256,
        .pixel_format = SG_PIXELFORMAT_DEPTH,
        .sample_count = 1,
    });

NOTE: when creating render target images, have in mind that some default values
are aligned with the default environment attributes in the sg_environment struct
that was passed into the sg_setup() call:

    - the default value for sg_image_desc.pixel_format is taken from
      sg_environment.defaults.color_format
    - the default value for sg_image_desc.sample_count is taken from
      sg_environment.defaults.sample_count
    - the default value for sg_image_desc.num_mipmaps is always 1

Next create an attachments object:

    const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){
        .colors[0].image = color_img,
        .depth_stencil.image = depth_img,
    });

This attachments object is then passed into the sg_begin_pass() function
in place of the swapchain struct:

    sg_begin_pass(&(sg_pass){ .attachments = atts });

Swapchain and offscreen passes form dependency trees each with a swapchain
pass at the root, offscreen passes as nodes, and render target images as
dependencies between passes.

sg_pass_action structs are used to define actions that should happen at the
start and end of rendering passes (such as clearing pass attachments to a
specific color or depth-value, or performing an MSAA resolve operation at
the end of a pass).

A typical sg_pass_action object which clears the color attachment to black
might look like this:

    const sg_pass_action = {
        .colors[0] = {
            .load_action = SG_LOADACTION_CLEAR,
            .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }
        }
    };

This omits the defaults for the color attachment store action, and
the depth-stencil-attachments actions. The same pass action with the
defaults explicitly filled in would look like this:

    const sg_pass_action pass_action = {
        .colors[0] = {
            .load_action = SG_LOADACTION_CLEAR,
            .store_action = SG_STOREACTION_STORE,
            .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }
        },
        .depth = = {
            .load_action = SG_LOADACTION_CLEAR,
            .store_action = SG_STOREACTION_DONTCARE,
            .clear_value = 1.0f,
        },
        .stencil = {
            .load_action = SG_LOADACTION_CLEAR,
            .store_action = SG_STOREACTION_DONTCARE,
            .clear_value = 0
        }
    };

With the sg_pass object and sg_pass_action struct in place everything
is ready now for the actual render pass:

Using such this prepared sg_pass_action in a swapchain pass looks like
this:

    sg_begin_pass(&(sg_pass){
        .action = pass_action,
        .swapchain = sglue_swapchain()
    });
    ...
    sg_end_pass();

...of alternatively in one offscreen pass:

    sg_begin_pass(&(sg_pass){
        .action = pass_action,
        .attachments = attachments,
    });
    ...
    sg_end_pass();

Offscreen rendering can also go into a mipmap, or a slice/face of
a cube-, array- or 3d-image (which some restrictions, for instance
it's not possible to create a 3D image with a depth/stencil pixel format,
these exceptions are generally caught by the sokol-gfx validation layer).

The mipmap/slice selection happens at attachments creation time, for instance
to render into mipmap 2 of slice 3 of an array texture:

    const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){
        .colors[0] = {
            .image = color_img,
            .mip_level = 2,
            .slice = 3,
        },
        .depth_stencil.image = depth_img,
    });

If MSAA offscreen rendering is desired, the multi-sample rendering result
must be 'resolved' into a separate 'resolve image', before that image can
be used as texture.

NOTE: currently multisample-images cannot be bound as textures.

Creating a simple attachments object for multisampled rendering requires
3 attachment images: the color attachment image which has a sample
count > 1, a resolve attachment image of the same size and pixel format
but a sample count == 1, and a depth/stencil attachment image with
the same size and sample count as the color attachment image:

    const sg_image color_img = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = 256,
        .height = 256,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .sample_count = 4,
    });
    const sg_image resolve_img = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = 256,
        .height = 256,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .sample_count = 1,
    });
    const sg_image depth_img = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = 256,
        .height = 256,
        .pixel_format = SG_PIXELFORMAT_DEPTH,
        .sample_count = 4,
    });

...create the attachments object:

    const sg_attachments atts = sg_make_attachments(&(sg_attachments_desc){
        .colors[0].image = color_img,
        .resolves[0].image = resolve_img,
        .depth_stencil.image = depth_img,
    });

If an attachments object defines a resolve image in a specific resolve attachment slot,
an 'msaa resolve operation' will happen in sg_end_pass().

In this scenario, the content of the MSAA color attachment doesn't need to be
preserved (since it's only needed inside sg_end_pass for the msaa-resolve), so
the .store_action should be set to "don't care":

    const sg_pass_action = {
        .colors[0] = {
            .load_action = SG_LOADACTION_CLEAR,
            .store_action = SG_STOREACTION_DONTCARE,
            .clear_value = { 0.0f, 0.0f, 0.0f, 1.0f }
        }
    };

The actual render pass looks as usual:

    sg_begin_pass(&(sg_pass){ .action = pass_action, .attachments = atts });
    ...
    sg_end_pass();

...after sg_end_pass() the only difference to the non-msaa scenario is that the
rendering result which is going to be used as texture in a followup pass is
in 'resolve_img', not in 'color_img' (in fact, trying to bind color_img as a
texture would result in a validation error).


ON SHADER CREATION
==================
sokol-gfx doesn't come with an integrated shader cross-compiler, instead
backend-specific shader sources or binary blobs need to be provided when
creating a shader object, along with information about the shader resource
binding interface needed in the sokol-gfx validation layer and to properly
bind shader resources on the CPU-side to be consumable by the GPU-side.

The easiest way to provide all this shader creation data is to use the
sokol-shdc shader compiler tool to compile shaders from a common
GLSL syntax into backend-specific sources or binary blobs, along with
shader interface information and uniform blocks mapped to C structs.

To create a shader using a C header which has been code-generated by sokol-shdc:

    // include the C header code-generated by sokol-shdc:
    #include "myshader.glsl.h"
    ...

    // create shader using a code-generated helper function from the C header:
    sg_shader shd = sg_make_shader(myshader_shader_desc(sg_query_backend()));

The samples in the 'sapp' subdirectory of the sokol-samples project
also use the sokol-shdc approach:

    https://github.com/floooh/sokol-samples/tree/master/sapp

If you're planning to use sokol-shdc, you can stop reading here, instead
continue with the sokol-shdc documentation:

    https://github.com/floooh/sokol-tools/blob/master/docs/sokol-shdc.md

To create shaders with backend-specific shader code or binary blobs,
the sg_make_shader() function requires the following information:

- Shader code or shader binary blobs for the vertex- and fragment- shader-stage:
    - for the desktop GL backend, source code can be provided in '#version 410' or
      '#version 430', version 430 is required for storage buffer support, but note
      that this is not available on macOS
    - for the GLES3 backend, source code must be provided in '#version 300 es' syntax
    - for the D3D11 backend, shaders can be provided as source or binary blobs, the
      source code should be in HLSL4.0 (for best compatibility) or alternatively
      in HLSL5.0 syntax (other versions may work but are not tested), NOTE: when
      shader source code is provided for the D3D11 backend, sokol-gfx will dynamically
      load 'd3dcompiler_47.dll'
    - for the Metal backends, shaders can be provided as source or binary blobs, the
      MSL version should be in 'metal-1.1' (other versions may work but are not tested)
    - for the WebGPU backend, shader must be provided as WGSL source code
    - optionally the following shader-code related attributes can be provided:
        - an entry function name (only on D3D11 or Metal, but not OpenGL)
        - on D3D11 only, a compilation target (default is "vs_4_0" and "ps_4_0")

- Depending on backend, information about the input vertex attributes used by the
  vertex shader:
    - Metal: no information needed since vertex attributes are always bound
      by their attribute location defined in the shader via '[[attribute(N)]]'
    - WebGPU: no information needed since vertex attributes are always
      bound by their attribute location defined in the shader via `@location(N)`
    - GLSL: vertex attribute names can be optionally provided, in that case their
      location will be looked up by name, otherwise, the vertex attribute location
      can be defined with 'layout(location = N)', PLEASE NOTE that the name-lookup method
      may be removed at some point
    - D3D11: a 'semantic name' and 'semantic index' must be provided for each vertex
      attribute, e.g. if the vertex attribute is defined as 'TEXCOORD1' in the shader,
      the semantic name would be 'TEXCOORD', and the semantic index would be '1'

- Information about each uniform block used in the shader:
    - The size of the uniform block in number of bytes.
    - A memory layout hint (currently 'native' or 'std140') where 'native' defines a
      backend-specific memory layout which shouldn't be used for cross-platform code.
      Only std140 guarantees a backend-agnostic memory layout.
    - For GLSL only: a description of the internal uniform block layout, which maps
      member types and their offsets on the CPU side to uniform variable names
      in the GLSL shader
    - please also NOTE the documentation sections about UNIFORM DATA LAYOUT
      and CROSS-BACKEND COMMON UNIFORM DATA LAYOUT below!

- A description of each storage buffer used in the shader:
    - a boolean 'readonly' flag, note that currently only
      readonly storage buffers are supported
    - note that storage buffers are not supported on all backends
      and platforms

- A description of each texture/image used in the shader:
    - the expected image type:
        - SG_IMAGETYPE_2D
        - SG_IMAGETYPE_CUBE
        - SG_IMAGETYPE_3D
        - SG_IMAGETYPE_ARRAY
    - the expected 'image sample type':
        - SG_IMAGESAMPLETYPE_FLOAT
        - SG_IMAGESAMPLETYPE_DEPTH
        - SG_IMAGESAMPLETYPE_SINT
        - SG_IMAGESAMPLETYPE_UINT
        - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT
    - a flag whether the texture is expected to be multisampled
      (currently it's not supported to fetch data from multisampled
      textures in shaders, but this is planned for a later time)

- A description of each texture sampler used in the shader:
    - SG_SAMPLERTYPE_FILTERING,
    - SG_SAMPLERTYPE_NONFILTERING,
    - SG_SAMPLERTYPE_COMPARISON,

- An array of 'image-sampler-pairs' used by the shader to sample textures,
  for D3D11, Metal and WebGPU this is used for validation purposes to check
  whether the texture and sampler are compatible with each other (especially
  WebGPU is very picky about combining the correct
  texture-sample-type with the correct sampler-type). For GLSL an
  additional 'combined-image-sampler name' must be provided because 'OpenGL
  style GLSL' cannot handle separate texture and sampler objects, but still
  groups them into a traditional GLSL 'sampler object'.

Compatibility rules for image-sample-type vs sampler-type are as follows:

    - SG_IMAGESAMPLETYPE_FLOAT => (SG_SAMPLERTYPE_FILTERING or SG_SAMPLERTYPE_NONFILTERING)
    - SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_SINT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_UINT => SG_SAMPLERTYPE_NONFILTERING
    - SG_IMAGESAMPLETYPE_DEPTH => SG_SAMPLERTYPE_COMPARISON

For example code of how to create backend-specific shader objects,
please refer to the following samples:

    - for D3D11:    https://github.com/floooh/sokol-samples/tree/master/d3d11
    - for Metal:    https://github.com/floooh/sokol-samples/tree/master/metal
    - for OpenGL:   https://github.com/floooh/sokol-samples/tree/master/glfw
    - for GLES3:    https://github.com/floooh/sokol-samples/tree/master/html5
    - for WebGPI:   https://github.com/floooh/sokol-samples/tree/master/wgpu


ON SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT AND SG_SAMPLERTYPE_NONFILTERING
========================================================================
The WebGPU backend introduces the concept of 'unfilterable-float' textures,
which can only be combined with 'nonfiltering' samplers (this is a restriction
specific to WebGPU, but since the same sokol-gfx code should work across
all backend, the sokol-gfx validation layer also enforces this restriction
- the alternative would be undefined behaviour in some backend APIs on
some devices).

The background is that some mobile devices (most notably iOS devices) can
not perform linear filtering when sampling textures with certain pixel
formats, most notable the 32F formats:

    - SG_PIXELFORMAT_R32F
    - SG_PIXELFORMAT_RG32F
    - SG_PIXELFORMAT_RGBA32F

The information of whether a shader is going to be used with such an
unfilterable-float texture must already be provided in the sg_shader_desc
struct when creating the shader (see the above section "ON SHADER CREATION").

If you are using the sokol-shdc shader compiler, the information whether a
texture/sampler binding expects an 'unfilterable-float/nonfiltering'
texture/sampler combination cannot be inferred from the shader source
alone, you'll need to provide this hint via annotation-tags. For instance
here is an example from the ozz-skin-sapp.c sample shader which samples an
RGBA32F texture with skinning matrices in the vertex shader:

```glsl
@image_sample_type joint_tex unfilterable_float
uniform texture2D joint_tex;
@sampler_type smp nonfiltering
uniform sampler smp;
```

This will result in SG_IMAGESAMPLETYPE_UNFILTERABLE_FLOAT and
SG_SAMPLERTYPE_NONFILTERING being written to the code-generated
sg_shader_desc struct.


UNIFORM DATA LAYOUT:
====================
NOTE: if you use the sokol-shdc shader compiler tool, you don't need to worry
about the following details.

The data that's passed into the sg_apply_uniforms() function must adhere to
specific layout rules so that the GPU shader finds the uniform block
items at the right offset.

For the D3D11 and Metal backends, sokol-gfx only cares about the size of uniform
blocks, but not about the internal layout. The data will just be copied into
a uniform/constant buffer in a single operation and it's up you to arrange the
CPU-side layout so that it matches the GPU side layout. This also means that with
the D3D11 and Metal backends you are not limited to a 'cross-platform' subset
of uniform variable types.

If you ever only use one of the D3D11, Metal *or* WebGPU backend, you can stop reading here.

For the GL backends, the internal layout of uniform blocks matters though,
and you are limited to a small number of uniform variable types. This is
because sokol-gfx must be able to locate the uniform block members in order
to upload them to the GPU with glUniformXXX() calls.

To describe the uniform block layout to sokol-gfx, the following information
must be passed to the sg_make_shader() call in the sg_shader_desc struct:

    - a hint about the used packing rule (either SG_UNIFORMLAYOUT_NATIVE or
      SG_UNIFORMLAYOUT_STD140)
    - a list of the uniform block members types in the correct order they
      appear on the CPU side

For example if the GLSL shader has the following uniform declarations:

    uniform mat4 mvp;
    uniform vec2 offset0;
    uniform vec2 offset1;
    uniform vec2 offset2;

...and on the CPU side, there's a similar C struct:

    typedef struct {
        float mvp[16];
        float offset0[2];
        float offset1[2];
        float offset2[2];
    } params_t;

...the uniform block description in the sg_shader_desc must look like this:

    sg_shader_desc desc = {
        .vs.uniform_blocks[0] = {
            .size = sizeof(params_t),
            .layout = SG_UNIFORMLAYOUT_NATIVE,  // this is the default and can be omitted
            .uniforms = {
                // order must be the same as in 'params_t':
                [0] = { .name = "mvp", .type = SG_UNIFORMTYPE_MAT4 },
                [1] = { .name = "offset0", .type = SG_UNIFORMTYPE_VEC2 },
                [2] = { .name = "offset1", .type = SG_UNIFORMTYPE_VEC2 },
                [3] = { .name = "offset2", .type = SG_UNIFORMTYPE_VEC2 },
            }
        }
    };

With this information sokol-gfx can now compute the correct offsets of the data items
within the uniform block struct.

The SG_UNIFORMLAYOUT_NATIVE packing rule works fine if only the GL backends are used,
but for proper D3D11/Metal/GL a subset of the std140 layout must be used which is
described in the next section:


CROSS-BACKEND COMMON UNIFORM DATA LAYOUT
========================================
For cross-platform / cross-3D-backend code it is important that the same uniform block
layout on the CPU side can be used for all sokol-gfx backends. To achieve this,
a common subset of the std140 layout must be used:

- The uniform block layout hint in sg_shader_desc must be explicitly set to
  SG_UNIFORMLAYOUT_STD140.
- Only the following GLSL uniform types can be used (with their associated sokol-gfx enums):
    - float => SG_UNIFORMTYPE_FLOAT
    - vec2  => SG_UNIFORMTYPE_FLOAT2
    - vec3  => SG_UNIFORMTYPE_FLOAT3
    - vec4  => SG_UNIFORMTYPE_FLOAT4
    - int   => SG_UNIFORMTYPE_INT
    - ivec2 => SG_UNIFORMTYPE_INT2
    - ivec3 => SG_UNIFORMTYPE_INT3
    - ivec4 => SG_UNIFORMTYPE_INT4
    - mat4  => SG_UNIFORMTYPE_MAT4
- Alignment for those types must be as follows (in bytes):
    - float => 4
    - vec2  => 8
    - vec3  => 16
    - vec4  => 16
    - int   => 4
    - ivec2 => 8
    - ivec3 => 16
    - ivec4 => 16
    - mat4  => 16
- Arrays are only allowed for the following types: vec4, int4, mat4.

Note that the HLSL cbuffer layout rules are slightly different from the
std140 layout rules, this means that the cbuffer declarations in HLSL code
must be tweaked so that the layout is compatible with std140.

The by far easiest way to tackle the common uniform block layout problem is
to use the sokol-shdc shader cross-compiler tool!

ON STORAGE BUFFERS
==================
Storage buffers can be used to pass large amounts of random access structured
data fromt the CPU side to the shaders. They are similar to data textures, but are
more convenient to use both on the CPU and shader side since they can be accessed
in shaders as as a 1-dimensional array of struct items.

Storage buffers are *NOT* supported on the following platform/backend combos:

- macOS+GL (because storage buffers require GL 4.3, while macOS only goes up to GL 4.1)
- all GLES3 platforms (WebGL2, iOS, Android - with the option that support on
  Android may be added at a later point)

Currently only 'readonly' storage buffers are supported (meaning it's not possible
to write to storage buffers from shaders).

To use storage buffers, the following steps are required:

    - write a shader which uses storage buffers (also see the example links below)
    - create one or more storage buffers via sg_make_buffer() with the
      buffer type SG_BUFFERTYPE_STORAGEBUFFER
    - when creating a shader via sg_make_shader(), populate the sg_shader_desc
      struct with binding info (when using sokol-shdc, this step will be taken care
      of automatically)
        - which storage buffer bind slots on the vertex- and fragment-stage
          are occupied
        - whether the storage buffer on that bind slot is readonly (this is currently required
          to be true)
    - when calling sg_apply_bindings(), apply the matching bind slots with the previously
      created storage buffers
    - ...and that's it.

For more details, see the following backend-agnostic sokol samples:

- simple vertex pulling from a storage buffer:
    - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.c
    - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/vertexpull-sapp.glsl
- instanced rendering via storage buffers (vertex- and instance-pulling):
    - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.c
    - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/instancing-pull-sapp.glsl
- storage buffers both on the vertex- and fragment-stage:
    - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.c
    - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/sbuftex-sapp.glsl
- the Ozz animation sample rewritten to pull all rendering data from storage buffers:
    - C code: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.cc
    - shader: https://github.com/floooh/sokol-samples/blob/master/sapp/ozz-storagebuffer-sapp.glsl

...also see the following backend-specific vertex pulling samples (those also don't use sokol-shdc):

- D3D11: https://github.com/floooh/sokol-samples/blob/master/d3d11/vertexpulling-d3d11.c
- desktop GL: https://github.com/floooh/sokol-samples/blob/master/glfw/vertexpulling-glfw.c
- Metal: https://github.com/floooh/sokol-samples/blob/master/metal/vertexpulling-metal.c
- WebGPU: https://github.com/floooh/sokol-samples/blob/master/wgpu/vertexpulling-wgpu.c

Storage buffer shader authoring caveats when using sokol-shdc:

    - declare a storage buffer interface block with `readonly buffer [name] { ... }`
    - do NOT annotate storage buffers with `layout(...)`, sokol-shdc will take care of that
    - declare a struct which describes a single array item in the storage buffer interface block
    - only put a single flexible array member into the storage buffer interface block

    E.g. a complete example in 'sokol-shdc GLSL':

    ```glsl
    // declare a struct:
    struct sb_vertex {
        vec3 pos;
        vec4 color;
    }
    // declare a buffer interface block with a single flexible struct array:
    readonly buffer vertices {
        sb_vertex vtx[];
    }
    // in the shader function, access the storage buffer like this:
    void main() {
        vec3 pos = vtx[gl_VertexIndex].pos;
        ...
    }
    ```

Backend-specific storage-buffer caveats (not relevant when using sokol-shdc):

    D3D11:
        - storage buffers are created as 'raw' Byte Address Buffers
          (https://learn.microsoft.com/en-us/windows/win32/direct3d11/overviews-direct3d-11-resources-intro#raw-views-of-buffers)
        - in HLSL, use a ByteAddressBuffer to access the buffer content
          (https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-byteaddressbuffer)
        - in D3D11, storage buffers and textures share the same bind slots, sokol-gfx reserves
          shader resource slots 0..15 for textures and 16..23 for storage buffers.
        - e.g. in HLSL, storage buffer bindings start at register(t16) no matter the shader stage

    Metal:
        - in Metal there is no internal difference between vertex-, uniform- and
          storage-buffers, all are bound to the same 'buffer bind slots' with the
          following reserved ranges:
            - vertex shader stage:
                - uniform buffers (internal): slots 0..3
                - vertex buffers: slots 4..11
                - storage buffers: slots 12..19
            - fragment shader stage:
                - uniform buffers (internal): slots 0..3
                - storage buffers: slots 4..11
        - this means in MSL, storage buffer bindings start at [[buffer(12)]] in the vertex
          shaders, and at [[buffer(4)]] in fragment shaders

    GL:
        - the GL backend doesn't use name-lookup to find storage buffer bindings, this
          means you must annotate buffers with `layout(std430, binding=N)` in GLSL
        - ...where N is 0..7 in the vertex shader, and 8..15 in the fragment shader

    WebGPU:
        - in WGSL, use the following bind locations for the various shader resource types:
        - vertex shader stage:
            - textures `@group(1) @binding(0..15)`
            - samplers `@group(1) @binding(16..31)`
            - storage buffers `@group(1) @binding(32..47)`
        - fragment shader stage:
            - textures `@group(1) @binding(48..63)`
            - samplers `@group(1) @binding(64..79)`
            - storage buffers `@group(1) @binding(80..95)`

TRACE HOOKS:
============
sokol_gfx.h optionally allows to install "trace hook" callbacks for
each public API functions. When a public API function is called, and
a trace hook callback has been installed for this function, the
callback will be invoked with the parameters and result of the function.
This is useful for things like debugging- and profiling-tools, or
keeping track of resource creation and destruction.

To use the trace hook feature:

--- Define SOKOL_TRACE_HOOKS before including the implementation.

--- Setup an sg_trace_hooks structure with your callback function
    pointers (keep all function pointers you're not interested
    in zero-initialized), optionally set the user_data member
    in the sg_trace_hooks struct.

--- Install the trace hooks by calling sg_install_trace_hooks(),
    the return value of this function is another sg_trace_hooks
    struct which contains the previously set of trace hooks.
    You should keep this struct around, and call those previous
    functions pointers from your own trace callbacks for proper
    chaining.

As an example of how trace hooks are used, have a look at the
imgui/sokol_gfx_imgui.h header which implements a realtime
debugging UI for sokol_gfx.h on top of Dear ImGui.


A NOTE ON PORTABLE PACKED VERTEX FORMATS:
=========================================
There are two things to consider when using packed
vertex formats like UBYTE4, SHORT2, etc which need to work
across all backends:

- D3D11 can only convert *normalized* vertex formats to
  floating point during vertex fetch, normalized formats
  have a trailing 'N', and are "normalized" to a range
  -1.0..+1.0 (for the signed formats) or 0.0..1.0 (for the
  unsigned formats):

    - SG_VERTEXFORMAT_BYTE4N
    - SG_VERTEXFORMAT_UBYTE4N
    - SG_VERTEXFORMAT_SHORT2N
    - SG_VERTEXFORMAT_USHORT2N
    - SG_VERTEXFORMAT_SHORT4N
    - SG_VERTEXFORMAT_USHORT4N

  D3D11 will not convert *non-normalized* vertex formats to floating point
  vertex shader inputs, those can only be uses with the *ivecn* vertex shader
  input types when D3D11 is used as backend (GL and Metal can use both formats)

    - SG_VERTEXFORMAT_BYTE4,
    - SG_VERTEXFORMAT_UBYTE4
    - SG_VERTEXFORMAT_SHORT2
    - SG_VERTEXFORMAT_SHORT4

For a vertex input layout which works on all platforms, only use the following
vertex formats, and if needed "expand" the normalized vertex shader
inputs in the vertex shader by multiplying with 127.0, 255.0, 32767.0 or
65535.0:

    - SG_VERTEXFORMAT_FLOAT,
    - SG_VERTEXFORMAT_FLOAT2,
    - SG_VERTEXFORMAT_FLOAT3,
    - SG_VERTEXFORMAT_FLOAT4,
    - SG_VERTEXFORMAT_BYTE4N,
    - SG_VERTEXFORMAT_UBYTE4N,
    - SG_VERTEXFORMAT_SHORT2N,
    - SG_VERTEXFORMAT_USHORT2N
    - SG_VERTEXFORMAT_SHORT4N,
    - SG_VERTEXFORMAT_USHORT4N
    - SG_VERTEXFORMAT_UINT10_N2
    - SG_VERTEXFORMAT_HALF2
    - SG_VERTEXFORMAT_HALF4


MEMORY ALLOCATION OVERRIDE
==========================
You can override the memory allocation functions at initialization time
like this:

    void* my_alloc(size_t size, void* user_data) {
        return malloc(size);
    }

    void my_free(void* ptr, void* user_data) {
        free(ptr);
    }

    ...
        sg_setup(&(sg_desc){
            // ...
            .allocator = {
                .alloc_fn = my_alloc,
                .free_fn = my_free,
                .user_data = ...,
            }
        });
    ...

If no overrides are provided, malloc and free will be used.

This only affects memory allocation calls done by sokol_gfx.h
itself though, not any allocations in OS libraries.


ERROR REPORTING AND LOGGING
===========================
To get any logging information at all you need to provide a logging callback in the setup call
the easiest way is to use sokol_log.h:

    #include "sokol_log.h"

    sg_setup(&(sg_desc){ .logger.func = slog_func });

To override logging with your own callback, first write a logging function like this:

    void my_log(const char* tag,                // e.g. 'sg'
                uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info
                uint32_t log_item_id,           // SG_LOGITEM_*
                const char* message_or_null,    // a message string, may be nullptr in release mode
                uint32_t line_nr,               // line number in sokol_gfx.h
                const char* filename_or_null,   // source filename, may be nullptr in release mode
                void* user_data)
    {
        ...
    }

...and then setup sokol-gfx like this:

    sg_setup(&(sg_desc){
        .logger = {
            .func = my_log,
            .user_data = my_user_data,
        }
    });

The provided logging function must be reentrant (e.g. be callable from
different threads).

If you don't want to provide your own custom logger it is highly recommended to use
the standard logger in sokol_log.h instead, otherwise you won't see any warnings or
errors.


COMMIT LISTENERS
================
It's possible to hook callback functions into sokol-gfx which are called from
inside sg_commit() in unspecified order. This is mainly useful for libraries
that build on top of sokol_gfx.h to be notified about the end/start of a frame.

To add a commit listener, call:

    static void my_commit_listener(void* user_data) {
        ...
    }

    bool success = sg_add_commit_listener((sg_commit_listener){
        .func = my_commit_listener,
        .user_data = ...,
    });

The function returns false if the internal array of commit listeners is full,
or the same commit listener had already been added.

If the function returns true, my_commit_listener() will be called each frame
from inside sg_commit().

By default, 1024 distinct commit listeners can be added, but this number
can be tweaked in the sg_setup() call:

    sg_setup(&(sg_desc){
        .max_commit_listeners = 2048,
    });

An sg_commit_listener item is equal to another if both the function
pointer and user_data field are equal.

To remove a commit listener:

    bool success = sg_remove_commit_listener((sg_commit_listener){
        .func = my_commit_listener,
        .user_data = ...,
    });

...where the .func and .user_data field are equal to a previous
sg_add_commit_listener() call. The function returns true if the commit
listener item was found and removed, and false otherwise.


RESOURCE CREATION AND DESTRUCTION IN DETAIL
===========================================
The 'vanilla' way to create resource objects is with the 'make functions':

    sg_buffer sg_make_buffer(const sg_buffer_desc* desc)
    sg_image sg_make_image(const sg_image_desc* desc)
    sg_sampler sg_make_sampler(const sg_sampler_desc* desc)
    sg_shader sg_make_shader(const sg_shader_desc* desc)
    sg_pipeline sg_make_pipeline(const sg_pipeline_desc* desc)
    sg_attachments sg_make_attachments(const sg_attachments_desc* desc)

This will result in one of three cases:

    1. The returned handle is invalid. This happens when there are no more
       free slots in the resource pool for this resource type. An invalid
       handle is associated with the INVALID resource state, for instance:

            sg_buffer buf = sg_make_buffer(...)
            if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_INVALID) {
                // buffer pool is exhausted
            }

    2. The returned handle is valid, but creating the underlying resource
       has failed for some reason. This results in a resource object in the
       FAILED state. The reason *why* resource creation has failed differ
       by resource type. Look for log messages with more details. A failed
       resource state can be checked with:

            sg_buffer buf = sg_make_buffer(...)
            if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_FAILED) {
                // creating the resource has failed
            }

    3. And finally, if everything goes right, the returned resource is
       in resource state VALID and ready to use. This can be checked
       with:

            sg_buffer buf = sg_make_buffer(...)
            if (sg_query_buffer_state(buf) == SG_RESOURCESTATE_VALID) {
                // creating the resource has failed
            }

When calling the 'make functions', the created resource goes through a number
of states:

    - INITIAL: the resource slot associated with the new resource is currently
      free (technically, there is no resource yet, just an empty pool slot)
    - ALLOC: a handle for the new resource has been allocated, this just means
      a pool slot has been reserved.
    - VALID or FAILED: in VALID state any 3D API backend resource objects have
      been successfully created, otherwise if anything went wrong, the resource
      will be in FAILED state.

Sometimes it makes sense to first grab a handle, but initialize the
underlying resource at a later time. For instance when loading data
asynchronously from a slow data source, you may know what buffers and
textures are needed at an early stage of the loading process, but actually
loading the buffer or texture content can only be completed at a later time.

For such situations, sokol-gfx resource objects can be created in two steps.
You can allocate a handle upfront with one of the 'alloc functions':

    sg_buffer sg_alloc_buffer(void)
    sg_image sg_alloc_image(void)
    sg_sampler sg_alloc_sampler(void)
    sg_shader sg_alloc_shader(void)
    sg_pipeline sg_alloc_pipeline(void)
    sg_attachments sg_alloc_attachments(void)

This will return a handle with the underlying resource object in the
ALLOC state:

    sg_image img = sg_alloc_image();
    if (sg_query_image_state(img) == SG_RESOURCESTATE_ALLOC) {
        // allocating an image handle has succeeded, otherwise
        // the image pool is full
    }

Such an 'incomplete' handle can be used in most sokol-gfx rendering functions
without doing any harm, sokol-gfx will simply skip any rendering operation
that involve resources which are not in VALID state.

At a later time (for instance once the texture has completed loading
asynchronously), the resource creation can be completed by calling one of
the 'init functions', those functions take an existing resource handle and
'desc struct':

    void sg_init_buffer(sg_buffer buf, const sg_buffer_desc* desc)
    void sg_init_image(sg_image img, const sg_image_desc* desc)
    void sg_init_sampler(sg_sampler smp, const sg_sampler_desc* desc)
    void sg_init_shader(sg_shader shd, const sg_shader_desc* desc)
    void sg_init_pipeline(sg_pipeline pip, const sg_pipeline_desc* desc)
    void sg_init_attachments(sg_attachments atts, const sg_attachments_desc* desc)

The init functions expect a resource in ALLOC state, and after the function
returns, the resource will be either in VALID or FAILED state. Calling
an 'alloc function' followed by the matching 'init function' is fully
equivalent with calling the 'make function' alone.

Destruction can also happen as a two-step process. The 'uninit functions'
will put a resource object from the VALID or FAILED state back into the
ALLOC state:

    void sg_uninit_buffer(sg_buffer buf)
    void sg_uninit_image(sg_image img)
    void sg_uninit_sampler(sg_sampler smp)
    void sg_uninit_shader(sg_shader shd)
    void sg_uninit_pipeline(sg_pipeline pip)
    void sg_uninit_attachments(sg_attachments pass)

Calling the 'uninit functions' with a resource that is not in the VALID or
FAILED state is a no-op.

To finally free the pool slot for recycling call the 'dealloc functions':

    void sg_dealloc_buffer(sg_buffer buf)
    void sg_dealloc_image(sg_image img)
    void sg_dealloc_sampler(sg_sampler smp)
    void sg_dealloc_shader(sg_shader shd)
    void sg_dealloc_pipeline(sg_pipeline pip)
    void sg_dealloc_attachments(sg_attachments atts)

Calling the 'dealloc functions' on a resource that's not in ALLOC state is
a no-op, but will generate a warning log message.

Calling an 'uninit function' and 'dealloc function' in sequence is equivalent
with calling the associated 'destroy function':

    void sg_destroy_buffer(sg_buffer buf)
    void sg_destroy_image(sg_image img)
    void sg_destroy_sampler(sg_sampler smp)
    void sg_destroy_shader(sg_shader shd)
    void sg_destroy_pipeline(sg_pipeline pip)
    void sg_destroy_attachments(sg_attachments atts)

The 'destroy functions' can be called on resources in any state and generally
do the right thing (for instance if the resource is in ALLOC state, the destroy
function will be equivalent to the 'dealloc function' and skip the 'uninit part').

And finally to close the circle, the 'fail functions' can be called to manually
put a resource in ALLOC state into the FAILED state:

    sg_fail_buffer(sg_buffer buf)
    sg_fail_image(sg_image img)
    sg_fail_sampler(sg_sampler smp)
    sg_fail_shader(sg_shader shd)
    sg_fail_pipeline(sg_pipeline pip)
    sg_fail_attachments(sg_attachments atts)

This is recommended if anything went wrong outside of sokol-gfx during asynchronous
resource setup (for instance a file loading operation failed). In this case,
the 'fail function' should be called instead of the 'init function'.

Calling a 'fail function' on a resource that's not in ALLOC state is a no-op,
but will generate a warning log message.

NOTE: that two-step resource creation usually only makes sense for buffers
and images, but not for samplers, shaders, pipelines or attachments. Most notably, trying
to create a pipeline object with a shader that's not in VALID state will
trigger a validation layer error, or if the validation layer is disabled,
result in a pipeline object in FAILED state. Same when trying to create
an attachments object with invalid image objects.


WEBGPU CAVEATS
==============
For a general overview and design notes of the WebGPU backend see:

    https://floooh.github.io/2023/10/16/sokol-webgpu.html

In general, don't expect an automatic speedup when switching from the WebGL2
backend to the WebGPU backend. Some WebGPU functions currently actually
have a higher CPU overhead than similar WebGL2 functions, leading to the
paradoxical situation that some WebGPU code may be slower than similar WebGL2
code.

- when writing WGSL shader code by hand, a specific bind-slot convention
  must be used:

  All uniform block structs must use `@group(0)`, with up to
  4 uniform blocks per shader stage.
    - Vertex shader uniform block bindings must start at `@group(0) @binding(0)`
    - Fragment shader uniform blocks bindings must start at `@group(0) @binding(4)`

  All textures and samplers must use `@group(1)` and start at specific
  offsets depending on resource type and shader stage.
    - Vertex shader textures must start at `@group(1) @binding(0)`
    - Vertex shader samplers must start at `@group(1) @binding(16)`
    - Vertex shader storage buffers must start at `@group(1) @binding(32)`
    - Fragment shader textures must start at `@group(1) @binding(48)`
    - Fragment shader samplers must start at `@group(1) @binding(64)`
    - Fragment shader storage buffers must start at `@group(1) @binding(80)`

  Note that the actual number of allowed per-stage texture- and sampler-bindings
  in sokol-gfx is currently lower than the above ranges (currently only up to
  12 textures, 8 samplers and 8 storage buffers are allowed per shader stage).

  If you use sokol-shdc to generate WGSL shader code, you don't need to worry
  about the above binding convention since sokol-shdc assigns bind slots
  automatically.

- The sokol-gfx WebGPU backend uses the sg_desc.uniform_buffer_size item
  to allocate a single per-frame uniform buffer which must be big enough
  to hold all data written by sg_apply_uniforms() during a single frame,
  including a worst-case 256-byte alignment (e.g. each sg_apply_uniform
  call will cost 256 bytes of uniform buffer size). The default size
  is 4 MB, which is enough for 16384 sg_apply_uniform() calls per
  frame (assuming the uniform data 'payload' is less than 256 bytes
  per call). These rules are the same as for the Metal backend, so if
  you are already using the Metal backend you'll be fine.

- sg_apply_bindings(): the sokol-gfx WebGPU backend implements a bindgroup
  cache to prevent excessive creation and destruction of BindGroup objects
  when calling sg_apply_bindings(). The number of slots in the bindgroups
  cache is defined in sg_desc.wgpu_bindgroups_cache_size when calling
  sg_setup. The cache size must be a power-of-2 number, with the default being
  1024. The bindgroups cache behaviour can be observed by calling the new
  function sg_query_frame_stats(), where the following struct items are
  of interest:

    .wgpu.num_bindgroup_cache_hits
    .wgpu.num_bindgroup_cache_misses
    .wgpu.num_bindgroup_cache_collisions
    .wgpu.num_bindgroup_cache_vs_hash_key_mismatch

  The value to pay attention to is `.wgpu.num_bindgroup_cache_collisions`,
  if this number if consistently higher than a few percent of the
  .wgpu.num_set_bindgroup value, it might be a good idea to bump the
  bindgroups cache size to the next power-of-2.

- sg_apply_viewport(): WebGPU currently has a unique restriction that viewport
  rectangles must be contained entirely within the framebuffer. As a shitty
  workaround sokol_gfx.h will clip incoming viewport rectangles against
  the framebuffer, but this will distort the clipspace-to-screenspace mapping.
  There's no proper way to handle this inside sokol_gfx.h, this must be fixed
  in a future WebGPU update.

- The sokol shader compiler generally adds `diagnostic(off, derivative_uniformity);`
  into the WGSL output. Currently only the Chrome WebGPU implementation seems
  to recognize this.

- The vertex format SG_VERTEXFORMAT_UINT10_N2 is currently not supported because
  WebGPU lacks a matching vertex format (this is currently being worked on though,
  as soon as the vertex format shows up in webgpu.h, sokol_gfx.h will add support.

- Likewise, the following sokol-gfx vertex formats are not supported in WebGPU:
  R16, R16SN, RG16, RG16SN, RGBA16, RGBA16SN and all PVRTC compressed format.
  Unlike unsupported vertex formats, unsupported pixel formats can be queried
  in cross-backend code via sg_query_pixel_format() though.

- The Emscripten WebGPU shim currently doesn't support the Closure minification
  post-link-step (e.g. currently the emcc argument '--closure 1' or '--closure 2'
  will generate broken Javascript code.

- sokol-gfx requires the WebGPU device feature `depth32float-stencil8` to be enabled
  (this should be widely supported)

- sokol-gfx expects that the WebGPU device feature `float32-filterable` to *not* be
  enabled (since this would exclude all iOS devices)


LICENSE
=======
zlib/libpng license

Copyright (c) 2018 Andre Weissflog

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software in a
    product, an acknowledgment in the product documentation would be
    appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not
    be misrepresented as being the original software.

    3. This notice may not be removed or altered from any source
    distribution.
