#!/usr/bin/env wrensh
var ctx = {}

var PATHSEP = "/"
var basename = Fn.new { |d|
  return d.split(PATHSEP)[-1]
}
var exists = Fn.new { |f|
  return !IO.Process(["ls", f]).test()
}
var iserror = Fn.new { |c|
  return (c is Num && c != 0)
}

var read_args = Fn.new {
  var args = IO.args()
  var nself = basename.call(args[0]) == "wrensh" ? 2 : 1

  var pkg_args = []
  for (argi in (nself + 1)...IO.argc()) {
    var arg = IO.arg(argi)
    if (arg == "--") {
      pkg_args = IO.args()[argi + 1..-1]
      break
    }
    if (arg.contains("=")) {
      var parts = arg.split("=")
      var key = parts[0]
      var value = parts[1..-1].join("=")
      ctx[key] = value
    } else {
      System.print("unrecognized argument %(arg), separate build script args with --")
      IO.exit(1)
    }
  }

  return {
    "prog": args[nself - 1],
    "self": args[0...nself],
    "nself": nself,
    "pkg": IO.argc() > nself ? IO.arg(nself) : null,
    "pkg_args": pkg_args,
  }
}

var ENV = IO.env()
var ARGS = read_args.call()

var argsquote = Fn.new { |args|
  var quoted = []
  for (arg in args) {
    arg.replace("\\", "\\\\")
    quoted.add("'%(arg)'")
  }
  return quoted.join(" ")
}

var get_pkgroot = Fn.new {
  var envval = ENV["XOS_PKG_ROOT"]
  if (envval && !envval.isEmpty) return envval
  envval = ENV["PKG"]
  if (envval && !envval.isEmpty) return envval
  if (exists.call("pkg")) {
    return "%(IO.cwd())/pkg"
  }
  System.print("could not find ./pkg dir. specify PKG= or run next to a pkg/ dir.")
}

var stale_dyndeps_ = Fn.new { |dyndeps_f, target|
  for (line in IO.run(["cat", dyndeps_f]).split("\n")) {
    if (line.isEmpty) continue
    var fields = line.split("  ")
    var depid = fields[0]
    var depname = fields[1]
    var depargs = fields[2..-1]
    var env = IO.env()
    env["TARGET"] = target
    var depid2 = IO.run(ARGS["self"] + depargs, env).trim()
    if (depid != depid2) return true
  }
  return false
}

var stale_dyndeps = Fn.new { |dyndeps_f|
  return stale_dyndeps_.call(dyndeps_f, ctx["TARGET"])
}

var stale_dyntooldeps = Fn.new { |dyndeps_f|
  return stale_dyndeps_.call(dyndeps_f, ctx["HOST"])
}

var get_host_triple = Fn.new {
  if (ctx["HOST"] && !ctx["HOST"].isEmpty) return ctx["HOST"]

  if (!IO.Process("which zig").test()) {
    for (line in IO.run("zig targets").split("\n")) {
      if (line.contains("\"triple\"")) {
        return line.split("\"")[3]
      }
    }
  }

  if (exists.call("%(ctx["XOS_ROOT"])/.xos_host")) {
    return IO.run(["cat", "$XOS_ROOT/.xos_host"]).trim()
  }

  System.print("could not determine HOST, please set manually")
  IO.exit(1)
}

var main = Fn.new {
  ctx["XOS_ROOT"] = ENV["XOS_ROOT"]
  ctx["XOS_BUILD_ROOT"] = ENV["XOS_BUILD_ROOT"]
  ctx["XOS_BUILD_CACHE"] = "%(ENV["XOS_BUILD_ROOT"])/cache"
  var tools_dir = "%(ctx["XOS_BUILD_CACHE"])/tools"

  var pkg = ARGS["pkg"]
  ctx["XOS_PKG_ROOT"] = get_pkgroot.call()
  if (ENV["DEV"] == "1" || ENV["XOS_USER_DEV"] == "1") {
    ctx["XOS_USER_DEV"] = 1
  }

  // determine package
  var pkg_args_str = argsquote.call(ARGS["pkg_args"])
  var build_pkg = "%(ctx["XOS_PKG_ROOT"])/%(pkg)"
  if (!exists.call("%(build_pkg)/build.sh")) {
    System.print("unrecognized pkg %(pkg), missing build.sh")
    IO.exit(1)
  }

  // xos version
  ctx["XOS_ID"] = ENV["XOS_ID"] || IO.run(["cat", "%(ctx["XOS_ROOT"])/.xos_id"]).trim()

  // Host and target triples
  ctx["HOST"] = get_host_triple.call()
  ctx["TARGET"] = ENV["TARGET"] || ctx["TARGET"] || ctx["HOST"]

  var host_parts = ctx["HOST"].split("-")
  ctx["HOST_ARCH"] = host_parts[0]
  ctx["HOST_OS"] = host_parts[1].split(".")[0]
  var target_parts = ctx["TARGET"].split("-")
  ctx["TARGET_ARCH"] = target_parts[0]
  ctx["TARGET_OS"] = target_parts[1].split(".")[0]

  var get_opt = Fn.new { |opt|
    var optz = null
    if (["0", "Debug"].contains(opt)) {
      opt = 0
      optz = "Debug"
    } else if (["1", "Safe"].contains(opt)) {
      opt = 1
      optz = "ReleaseSafe"
    } else if (["2", "Fast"].contains(opt)) {
      opt = 2
      optz = "ReleaseFast"
    } else if (["Small"].contains(opt)) {
      opt = "s"
      optz = "ReleaseSmall"
    } else if (["3", "fast"].contains(opt)) {
      opt = opt
      optz = "ReleaseFast"
    } else if (["s", "z"].contains(opt)) {
      opt = opt
      optz = "ReleaseSmall"
    } else {
      System.print("unrecognized OPT=%(opt)")
      IO.exit(1)
    }
    return {
      "c": opt,
      "zig": optz,
    }
  }

  var opt = ENV["OPT"] || "s"
  opt = get_opt.call(opt)

  // identify pkg id
  var pkgid_text = IO.run(["%(ctx["XOS_ROOT"])/tools/xos_internal_pkgid", pkg], {
    "PATH": ENV["PATH"],
    "XOS": ctx["XOS_ID"],
    "BUILD_PKG": build_pkg,
    "TARGET": ctx["TARGET"],
    "OPT": opt["c"],
    "ARGS": pkg_args_str,
  })

  var sha256 = Fn.new { |val|
    var out = IO.run(["sh", "-c", "echo \"%(val)\" | sha256sum"])
    return out.split(" ")[0]
  }

  var pkgid = sha256.call(pkgid_text)
  var pkgid_prefix = pkgid[0...2]
  var build_out = "%(ctx["XOS_BUILD_CACHE"])/pkg/%(pkgid_prefix)/%(pkgid)"

  if (ctx["XOS_USER_DEV"] != 1 && exists.call("%(build_pkg)/dev_volatile")) {
    System.print("warn: %(pkg) marked volatile, but DEV != 1, consider unmarking")
  }


  var need_rebuild = Fn.new {
    if (!exists.call("%(build_out)/.ok")) return "y, not built"
    if (ctx["XOS_USER_DEV"] = 1 && exists.call("%(build_pkg)/dev_volatile")) return "y, volatile"
    if (exists.call("%(build_out)/dyndeps.txt") && stale_dyndeps.call("%(build_out)/dyndeps.txt")) return "y, dyndeps stale"
    if (exists.call("%(build_out)/dyntooldeps.txt") && stale_dyntooldeps.call("%(build_out)/dyntooldeps.txt")) return "y, dyntoolteps stale"
    return null
  }

  // dependencies
  var rebuild = need_rebuild.call()

  if (ENV["XOS_DRY"] == "1" || ctx["DRY"] == "1") {
    ctx["XOS_DRY"] = 1

    var dry_log = "
  ---
  build %(pkg) %(pkg_args_str)
  BUILD_PKG=%(build_pkg)
  BUILD_OUT=%(build_out)
  TARGET=%(ctx["TARGET"])
  HOST=%(ctx["HOST"])
  OPT=%(opt["c"])
  OPT_ZIG=%(opt["zig"])
  XOS_ROOT=%(ctx["XOS_ROOT"])
  XOS_PKG_ROOT=%(ctx["XOS_PKG_ROOT"])
  XOS_BUILD_ROOT=%(ctx["XOS_BUILD_ROOT"])
  XOS_BUILD_CACHE=%(ctx["XOS_BUILD_CACHE"])
  XOS_ID=%(ctx["XOS_ID"])
  rebuild=%(rebuild)
  ---
  "
    System.print(dry_log)
    IO.writeln(pkgid)
    IO.exit(0)
  }

  // build if necessary
  if (rebuild) {
    IO.run(["rm", "-rf", build_out])
    IO.run(["mkdir", "-p", "%(build_out)/out", "%(build_out)/tmp"])
    IO.Process(["echo", pkgid_text]).stdout("%(build_out)/pkgid").run()

    // pkg-specific tools
    var pkg_tools_dir = "%(build_out)/tools"
    IO.run(["mkdir", "-p", pkg_tools_dir])
    var mktemp = "#!/usr/bin/env sh
  set -e
  xos_internal_mktemp \"$@\" \"%(build_out)/tmp/tmpXXXXXX\"
  "
    IO.Process(["echo", mktemp]).stdout("%(pkg_tools_dir)/mktemp").run()
    IO.run(["chmod", "+x", "%(pkg_tools_dir)/mktemp"])

    // setup log and interrupt/fail fns
    var logfile = "%(build_out)/build.log"

    var fail = Fn.new {
      IO.Process(["cat", logfile]).stdout(2).run()
      System.print("failed building pkg %(pkg) %(pkgid)")
      IO.exit(1)
    }

    var trap = IO.trap(2, Fn.new {
      IO.Process(["cat", logfile]).stdout(2).run()
      System.print("interrupted building pkg %(pkg) %(pkgid)")
      IO.exit(1)
    })

    // run build script
    IO.chdir("%(build_out)/tmp")
    var script = "%(build_pkg)/build.sh"

    ctx["PATH"] = "%(pkg_tools_dir):%(tools_dir):%(ctx["XOS_ROOT"])/tools"
    ctx["HOME"] = "%(build_out)/tmp"
    ctx["USER"] = "xos"
    ctx["XDG_CACHE_HOME"] = "%(ctx["XOS_BUILD_CACHE"])/xdg"
    ctx["XOS_SEAL"] = 1
    ctx["XOS_BUILD_OUT"] = "%(build_out)"
    ctx["OPT"] = opt["c"]
    ctx["OPT_ZIG"] = opt["zig"]
    ctx["BUILD_OUT"] = "%(build_out)/out"
    ctx["BUILD_DEPS"] = "%(build_out)/deps"
    ctx["BUILD_TOOLDEPS"] = "%(build_out)/tooldeps"
    ctx["BUILD_PKG"] = "%(build_pkg)"
    var out = IO.Process(["sh", "-e", script] + ARGS["pkg_args"])
      .env(ctx)
      .stdout(logfile)
      .runc()
    trap.cancel()
    if (iserror.call(out)) fail.call()

    // ok
    IO.run(["touch", "%(build_out)/.ok"])
  }

  // link to build/out
  IO.run(["rm", "-f", "%(ctx["XOS_BUILD_ROOT"])/out"])
  IO.run(["ln", "-s", "%(build_out)/out", "%(ctx["XOS_BUILD_ROOT"])/out"])
  IO.writeln(pkgid)
}

main.call()
